# 1. Оптимізація доступу до даних за допомогою LRU-кешу
Програма реалізує оптимізацію обробки запитів до масиву чисел за допомогою LRU-кешу.  

Для порівняння продуктивності реалізовані два підходи:
- без кешування (перерахунок кожного разу).  
- з використанням LRU-кешу (збереження результатів попередніх запитів).  

## Тестові параметри
Розмір масиву: 100000 елементів.  
Кількість запитів: 50000 (випадкове співвідношення Range та Update).  
Розмір кешу: 1000 записів.  
Кількість запусків для тестування: 20.  

## Результати виконання
1. Час виконання без кешування (20 запусків): 131.54 секунд
2. Час виконання з LRU-кешем (20 запусків): 133.17 секунд

## Аналіз результатів
LRU-кешування не покращило продуктивність, а навіть трохи збільшило час виконання.

### Основні причини:
1. Більшість Range(L, R) запитів унікальні, тому кеш майже не використовується повторно.
2. Часті Update(index, value) знищують кешовані значення, що знижує ефективність кешування.
3. Додаткові витрати на підтримку кешу (оновлення зв'язного списку та хеш-таблиці).

### Можливі покращення
Дерево відрізків (Segment Tree) – дозволяє обчислювати Range(L, R) та Update(index, value) за O(log N).  
Дерево Фенвіка (Fenwick Tree, BIT) – швидше за LRU-кеш, але простіше, ніж дерево відрізків.  
Префіксні суми – ефективне Range(L, R), але повільні оновлення (O(N)).  

## Висновки
LRU-кеш не підходить для цього типу задачі, оскільки:
- запити Range(L, R) не повторюються достатньо часто.
- Update(index, value) знищує кеш.


# 2. Порівняння продуктивності обчислення чисел Фібоначчі: LRU Cache vs Splay Tree
Ця програма реалізує два підходи до обчислення чисел Фібоначчі:
- LRU Cache – використання декоратора @lru_cache для кешування результатів.  
- Splay Tree – використання структури Splay Tree для збереження попередньо обчислених значень.  
Вимірюється середній час виконання кожного підходу для значень n від 0 до 950 з кроком 50.

## Результати
Програма виводить таблицю з середнім часом виконання для обох підходів та будує графік, що демонструє різницю в продуктивності.  

<img width="368" alt="Screenshot 2025-03-10 at 18 10 19" src="https://github.com/user-attachments/assets/97be0324-c431-4069-a481-43e4721f251b" />
<img width="854" alt="Screenshot 2025-03-10 at 18 09 41" src="https://github.com/user-attachments/assets/96a25b34-b8b3-42e0-9b8e-53e04e67682b" />

  
На графіку видно, що LRU Cache має значно менший середній час виконання у порівнянні з Splay Tree, особливо для більших значень n. 

### Висновки
LRU Cache ефективніший, оскільки дозволяє зменшити кількість обчислень завдяки автоматичному кешуванню результатів.  
Splay Tree повільніший, оскільки додаткові операції пошуку та переструктурування дерева додають накладні витрати.  
Для великих значень n (n > 100) LRU Cache забезпечує стабільно швидке виконання, тоді як Splay Tree демонструє стабільний, але значно вищий час виконання.  
Отже, для швидкого обчислення чисел Фібоначчі варто використовувати LRU Cache.

